#include <bits/stdc++.h>
using namespace std;
#include <iomanip>
#include <chrono>
#include <filesystem>

// --------------------- Timer ---------------------
using hires_clock = std::chrono::high_resolution_clock;
using duration_ms = std::chrono::duration<double, std::milli>;

struct Stopwatch {
    hires_clock::time_point start;
    Stopwatch() : start(hires_clock::now()) {}
    void reset() { start = hires_clock::now(); }
    double elapsed_ms() const {
        return duration_ms(hires_clock::now() - start).count();
    }
};

// Simple in-terminal progress bar
void print_progress(double progress, const string& label) {
    int bar_width = 40; // width of the bar
    if (progress > 1.0) progress = 1.0;
    if (progress < 0.0) progress = 0.0;
    int pos = (int)(bar_width * progress);
    
    cerr << "  [";
    for (int i = 0; i < bar_width; ++i) {
        if (i < pos) cerr << "=";
        else if (i == pos) cerr << ">";
        else cerr << " ";
    }
    cerr << "] " << (int)(progress * 100.0 + 0.5) << "% "
         << label << "                \r"; 
    cerr.flush();
}

// --------------------- Data structures ---------------------
struct Point { int x{}, y{}; };

struct Instance {
    string name;
    vector<Point> pts;         
    vector<int>    cost;       
    vector<vector<int>> D;     
    int N = 0;
    int K = 0;                 
};

static inline int iround(double v) {
    return (int) llround(v);
}

static vector<string> split_tokens(const string& line) {
    vector<string> out;
    string token;
    for (size_t i = 0; i < line.size(); ++i) {
        char c = line[i];
        if (c == ';' || isspace((unsigned char)c)) {
            if (!token.empty()) { out.push_back(token); token.clear(); }
        } else {
            token.push_back(c);
        }
    }
    if (!token.empty()) out.push_back(token);
    return out;
}

bool read_instance(const string& path, Instance& inst) {
    ifstream in(path); 
    if (!in) { 
        cerr << "Cannot open: " << path << "\n";
        return false;
    }

    inst.name = filesystem::path(path).stem().string(); 
    inst.pts.clear(); 
    inst.cost.clear(); 

    string line;
    while (getline(in, line)) {
        string s = line;
        auto start = s.find_first_not_of(" \t\r\n"); 
        if (start == string::npos) continue; 
        s = s.substr(start); 
        if (s.rfind("#", 0) == 0) continue;  
        if (s.rfind("//", 0) == 0) continue; 

        auto toks = split_tokens(s); 
        if (toks.empty()) continue; 
        if (toks.size() < 3) { 
            cerr << "Skipping malformed line: " << line << "\n";
            continue;
        }

        Point p{ stoi(toks[0]), stoi(toks[1]) }; 
        int c = stoi(toks[2]); 
        inst.pts.push_back(p); 
        inst.cost.push_back(c); 
    }

    inst.N = (int)inst.pts.size(); 
    if (inst.N < 3) {
        cerr << "Instance must have at least 3 nodes.\n";
        return false;
    }
    inst.K = (inst.N + 1) / 2; 

    inst.D.assign(inst.N, vector<int>(inst.N, 0)); 
    for (int i = 0; i < inst.N; ++i) {
        for (int j = i+1; j < inst.N; ++j) {
            long dx = (long)inst.pts[i].x - inst.pts[j].x;
            long dy = (long)inst.pts[i].y - inst.pts[j].y;
            int d = iround(sqrt((double)dx*dx + (double)dy*dy)); 
            inst.D[i][j] = inst.D[j][i] = d; 
        }
    }
    return true;
}

// --------------------- Objective / checking ---------------------
long long tour_edge_sum(const vector<int>& tour, const vector<vector<int>>& D) {
    long long s = 0;
    int m = (int)tour.size();
    if (m == 0) return 0;
    for (int i = 0; i < m; ++i) {
        int u = tour[i];
        int v = tour[(i+1)%m]; 
        s += D[u][v];
    }
    return s;
}

long long tour_cost_sum(const vector<int>& tour, const vector<int>& C) {
    long long s = 0;
    for (int v : tour) s += C[v]; 
    return s;
}

long long objective(const vector<int>& tour, const Instance& I) {
    return tour_edge_sum(tour, I.D) + tour_cost_sum(tour, I.cost);
}

bool check_solution(const vector<int>& tour, const Instance& I, string* why=nullptr) {
    int K = I.K;
    if ((int)tour.size() != K) { if (why) *why = "wrong size"; return false; }

    vector<int> seen(I.N, 0);
    
    for (int v : tour) {
        if (v < 0 || v >= I.N) { if (why) *why = "index out of range"; return false; }
        if (seen[v]) { if (why) *why = "repeated node"; return false; }
        seen[v] = 1;
    }
    return true;
}

// --------------------- Helpers ---------------------
template<class T>
int argmin_random_tie(const vector<T>& vals, mt19937& rng) {
    T best = vals[0];
    vector<int> idx{0};
    for (int i = 1; i < (int)vals.size(); ++i) {
        if (vals[i] < best) { best = vals[i]; idx.assign(1, i); }
        else if (vals[i] == best) idx.push_back(i);
    }
    uniform_int_distribution<int> dist(0, (int)idx.size()-1);
    return idx[dist(rng)];
}

template<typename T>
void insert_at(vector<T>& v, int pos, const T& val) {
    v.insert(v.begin()+pos, val);
}

// ---------- Local Search Helpers ----------
struct LSHelpers {
    int K, N;
    vector<int>& tour; 
    vector<int> pos;   
    vector<bool> in_tour; 

    LSHelpers(int n, int k, vector<int>& t) : N(n), K(k), tour(t), pos(n, -1), in_tour(n, false) {
        build();
    }
    
    void build() {
        fill(pos.begin(), pos.end(), -1);
        fill(in_tour.begin(), in_tour.end(), false);
        for (int i = 0; i < K; ++i) {
            int node = tour[i];
            pos[node] = i;
            in_tour[node] = true;
        }
    }
};

static long long delta_inter_exchange(int u, int v, const LSHelpers& h, const Instance& I) {
    const auto& D = I.D; const auto& C = I.cost;
    int K = h.K;
    int i = h.pos[u]; 
    int prev_u = h.tour[(i - 1 + K) % K];
    int next_u = h.tour[(i + 1) % K];

    long long cost_delta = (long long)C[v] - C[u];
    long long edge_delta = (long long)D[prev_u][v] + D[v][next_u] 
                         - D[prev_u][u] - D[u][next_u];

    return cost_delta + edge_delta;
} 

static long long delta_intra_exchange_nodes(int i, int j, const LSHelpers& h, const Instance& I) {
    const auto& D = I.D;
    int K = h.K;
    if (i == j) return 0;
    if (j < i) swap(i, j); 

    int u = h.tour[i];
    int v = h.tour[j];

    int prev_i = h.tour[(i - 1 + K) % K]; 
    int next_i = h.tour[(i + 1) % K]; 
    int prev_j = h.tour[(j - 1 + K) % K]; 
    int next_j = h.tour[(j + 1) % K]; 

    long long delta = 0;

    if (j == i + 1) { 
        delta = (long long)D[prev_i][v] + D[v][u] + D[u][next_j]
              - D[prev_i][u] - D[u][v] - D[v][next_j];
    } else if (i == 0 && j == K - 1) { 
        delta = (long long)D[prev_j][u] + D[u][v] + D[v][next_i]
              - D[prev_j][v] - D[v][u] - D[u][next_i];
    }
    else { 
        delta = (long long)D[prev_i][v] + D[v][next_i] + D[prev_j][u] + D[u][next_j]
              - D[prev_i][u] - D[u][next_i] - D[prev_j][v] - D[v][next_j];
    }
    return delta;
}

static long long delta_intra_exchange_edges_2opt(int i, int j, const LSHelpers& h, const Instance& I) {
    const auto& D = I.D;
    int K = h.K;
    if (j < i) swap(i, j); 

    int u = h.tour[i]; 
    int v = h.tour[(i + 1) % K]; 
    int x = h.tour[j]; 
    int y = h.tour[(j + 1) % K]; 

    if (v == x || u == y) return 0;

    long long delta = (long long)D[u][x] + D[v][y] - D[u][v] - D[x][y]; 
    return delta;
}

static void apply_inter_exchange(LSHelpers& h, int u, int v) {
    int i = h.pos[u];
    h.tour[i] = v; 
    h.pos[u] = -1;
    h.in_tour[u] = false;  
    h.pos[v] = i;
    h.in_tour[v] = true;   
}

static void apply_intra_exchange_nodes(LSHelpers& h, int i, int j) {
    int u = h.tour[i];
    int v = h.tour[j];
    swap(h.tour[i], h.tour[j]);  
    h.pos[u] = j;
    h.pos[v] = i;
}

static void apply_intra_exchange_edges_2opt(LSHelpers& h, int i, int j) {
    int K = h.K;
    if (j < i) swap(i, j);
    int start = (i + 1) % K;
    int end = j;
    while (start != end) {
        int u = h.tour[start]; 
        int v = h.tour[end];
        swap(h.tour[start], h.tour[end]); 
        h.pos[u] = end; 
        h.pos[v] = start; 
        start = (start + 1) % K; 
        if (start == end) break; 
        end = (end - 1 + K) % K; 
    }
}

enum IntraMoveType { NODE_EXCHANGE, EDGE_EXCHANGE_2OPT };

// ---- Steep Local Search ----
vector<int> local_search_steepest(
    const vector<int>& initial_tour, 
    const Instance& I, 
    IntraMoveType intra_mode, 
    mt19937& rng) 
{
    vector<int> tour = initial_tour;
    LSHelpers h(I.N, I.K, tour);
    
    vector<int> nodes_in_tour = tour;
    vector<int> nodes_not_in_tour;
    for (int i = 0; i < I.N; ++i) {
        if (!h.in_tour[i]) {
            nodes_not_in_tour.push_back(i);
        }
    }

    while (true) {
        long long best_delta = 0;
        int best_move_type = -1; // 0: inter, 1: intra
        int best_u = -1, best_v = -1; 
        int best_i = -1, best_j = -1; 

        // 1. Evaluate all Inter-route moves (node exchange)
        for (int u : nodes_in_tour) {
            for (int v : nodes_not_in_tour) {
                long long delta = delta_inter_exchange(u, v, h, I);
                if (delta < best_delta) {
                    best_delta = delta;
                    best_move_type = 0;
                    best_u = u;
                    best_v = v;
                }
            }
        }

        // 2. Evaluate all Intra-route moves
        if (intra_mode == NODE_EXCHANGE) {
            for (int i = 0; i < I.K; ++i) {
                for (int j = i + 1; j < I.K; ++j) {
                    long long delta = delta_intra_exchange_nodes(i, j, h, I);
                    if (delta < best_delta) {
                        best_delta = delta;
                        best_move_type = 1;
                        best_i = i;
                        best_j = j;
                    }
                }
            }
        } else { // EDGE_EXCHANGE_2OPT
            for (int i = 0; i < I.K; ++i) {
                for (int j = i + 1; j < I.K; ++j) { 
                    long long delta = delta_intra_exchange_edges_2opt(i, j, h, I);
                     if (delta < best_delta) {
                        best_delta = delta;
                        best_move_type = 1;
                        best_i = i;
                        best_j = j;
                    }
                }
            }
        }
        
        // 3. Apply best move
        if (best_delta < -1e-9) {
            if (best_move_type == 0) {
                apply_inter_exchange(h, best_u, best_v);
                for (size_t i = 0; i < nodes_in_tour.size(); ++i) {
                    if (nodes_in_tour[i] == best_u) {
                        nodes_in_tour[i] = best_v;
                        break;
                    }
                }
                for (size_t i = 0; i < nodes_not_in_tour.size(); ++i) {
                    if (nodes_not_in_tour[i] == best_v) {
                        nodes_not_in_tour[i] = best_u;
                        break;
                    }
                }

            } else { 
                if (intra_mode == NODE_EXCHANGE) {
                    apply_intra_exchange_nodes(h, best_i, best_j);
                } else {
                    apply_intra_exchange_edges_2opt(h, best_i, best_j);
                }
            }
        } else {
            break; 
        }
    }
    return tour;
}

// --------------------- Basic Heuristics for Init ---------------------
vector<int> random_solution(const Instance& I, mt19937& rng, int start_anchor = -1) {
    vector<int> nodes(I.N); 
    iota(nodes.begin(), nodes.end(), 0); 
    if (start_anchor >= 0) {
        swap(nodes[0], nodes[start_anchor]);
        shuffle(nodes.begin()+1, nodes.end(), rng); 
        vector<int> sel; 
        sel.reserve(I.K); 
        sel.push_back(nodes[0]); 
        for (int i = 1; (int)sel.size() < I.K; ++i) sel.push_back(nodes[i]); 
        shuffle(sel.begin(), sel.end(), rng); 
        return sel;
    } else {
        shuffle(nodes.begin(), nodes.end(), rng); 
        vector<int> sel(nodes.begin(), nodes.begin()+I.K); 
        shuffle(sel.begin(), sel.end(), rng); 
        return sel;
    }
}

// One run of basic local search (for MSLS/ILS)
vector<int> basic_LS_for_meta(const Instance& I, mt19937& rng, double& elapsed_ms) {
    Stopwatch sw;
    auto start_tour = random_solution(I, rng, -1);
    // Use the function defined above
    auto improved = local_search_steepest(start_tour, I, EDGE_EXCHANGE_2OPT, rng);
    elapsed_ms = sw.elapsed_ms();
    return improved;
}

// =========================================================================
//                   LARGE NEIGHBORHOOD SEARCH (LNS) OPS
// =========================================================================

namespace LNS_Ops {

    // --- Destroy Utils ---
    template<typename T>
    int roulette_select(const vector<T>& candidates, const vector<double>& scores, double total_score, mt19937& rng) {
        if (total_score <= 1e-9) {
            uniform_int_distribution<int> dist(0, (int)candidates.size() - 1);
            return dist(rng);
        }
        uniform_real_distribution<double> dist(0.0, total_score);
        double r = dist(rng);
        double accumulator = 0.0;
        for (size_t i = 0; i < candidates.size(); ++i) {
            accumulator += scores[i];
            if (accumulator >= r) return (int)i;
        }
        return (int)candidates.size() - 1; 
    }

    // --- Destroy Nodes (Weighted by Cost + Detour) ---
    void destroy_nodes(vector<int>& tour, int n_remove, const Instance& I, mt19937& rng) {
        const auto& D = I.D;
        const auto& C = I.cost;

        for (int k = 0; k < n_remove; ++k) {
            if (tour.size() <= 2) break; 
            vector<double> scores;
            scores.reserve(tour.size());
            double total_score = 0;
            int m = (int)tour.size();

            for (int i = 0; i < m; ++i) {
                int u = tour[i];
                int prev = tour[(i - 1 + m) % m];
                int next = tour[(i + 1) % m];
                long long detour = (long long)D[prev][u] + D[u][next] - D[prev][next];
                double score = (double)(C[u] + detour); 
                if (score < 0) score = 0; 
                scores.push_back(score);
                total_score += score;
            }

            // Roulette selection simulation without creating candidate vector
            int remove_idx = -1;
            if (total_score <= 1e-9) {
                uniform_int_distribution<int> dist(0, m - 1);
                remove_idx = dist(rng);
            } else {
                uniform_real_distribution<double> dist(0.0, total_score);
                double r = dist(rng);
                double acc = 0.0;
                remove_idx = m - 1;
                for(int i=0; i<m; ++i) {
                    acc += scores[i];
                    if (acc >= r) { remove_idx = i; break; }
                }
            }
            tour.erase(tour.begin() + remove_idx);
        }
    }

    // --- Destroy Edges (Weighted by Length) ---
    void destroy_edges(vector<int>& tour, int n_remove, const Instance& I, mt19937& rng) {
        const auto& D = I.D;
        const auto& C = I.cost;
        
        for (int k = 0; k < n_remove; ++k) {
            if (tour.size() <= 2) break;
            vector<double> scores;
            int m = (int)tour.size();
            scores.reserve(m);
            double total_score = 0;

            for (int i = 0; i < m; ++i) {
                int u = tour[i];
                int v = tour[(i + 1) % m];
                double score = (double)D[u][v]; 
                scores.push_back(score);
                total_score += score;
            }

            int edge_idx = -1;
            if (total_score <= 1e-9) {
                uniform_int_distribution<int> dist(0, m - 1);
                edge_idx = dist(rng);
            } else {
                uniform_real_distribution<double> dist(0.0, total_score);
                double r = dist(rng);
                double acc = 0.0;
                edge_idx = m - 1;
                for(int i=0; i<m; ++i) {
                    acc += scores[i];
                    if (acc >= r) { edge_idx = i; break; }
                }
            }

            // Break edge (u,v) -> remove node with higher cost
            int u_idx = edge_idx;
            int v_idx = (edge_idx + 1) % m;
            int u = tour[u_idx];
            int v = tour[v_idx];
            if (C[u] > C[v]) tour.erase(tour.begin() + u_idx);
            else tour.erase(tour.begin() + v_idx);
        }
    }

    // --- Repair Regret (Greedy 2-Regret for Partial Tour) ---
    void repair_regret(vector<int>& tour, const Instance& I, mt19937& rng) {
        const auto& D = I.D; 
        const auto& C = I.cost; 
        int K = I.K; 
        int N = I.N;

        vector<char> used(N, 0);
        for (int x : tour) used[x] = 1;

        while ((int)tour.size() < K) {
            int m = (int)tour.size();
            long long best_regret = LLONG_MIN;
            int best_node = -1;
            int best_insert_pos = -1;     
            long long best_actual_cost = LLONG_MAX; 

            for (int j = 0; j < N; ++j) if (!used[j]) {
                long long c1 = LLONG_MAX;
                long long c2 = LLONG_MAX;
                int pos_c1 = -1;

                for (int i = 0; i < m; ++i) {
                    int u = tour[i]; 
                    int v = tour[(i+1)%m];
                    long long delta = (long long)D[u][j] + D[j][v] - D[u][v];
                    long long total = delta + C[j];
                    if (total < c1) {
                        c2 = c1; c1 = total; pos_c1 = i;
                    } else if (total < c2) {
                        c2 = total;
                    }
                }
                if (c2 == LLONG_MAX) c2 = c1; 

                long long regret = c2 - c1;
                bool is_better = false;
                if (regret > best_regret) is_better = true;
                else if (regret == best_regret) {
                    if (c1 < best_actual_cost) is_better = true;
                    else if (c1 == best_actual_cost) {
                         if (uniform_int_distribution<int>(0,1)(rng)) is_better = true;
                    }
                }

                if (is_better) {
                    best_regret = regret;
                    best_node = j;
                    best_insert_pos = pos_c1;
                    best_actual_cost = c1;
                }
            }

            if (best_node != -1) {
                tour.insert(tour.begin() + (best_insert_pos + 1), best_node);
                used[best_node] = 1;
            } else break; 
        }
    }

    // --- MAIN LNS RUNNER ---
    // Returns {best_tour, iterations}
    pair<vector<int>, int> run_LNS(const Instance& I, double T_max_ms, bool use_ls, mt19937& rng) {
        Stopwatch sw;
        
        // 1. Initial Solution (Random + LS)
        // Always apply LS to start, as requested
        auto S_curr = random_solution(I, rng, -1);
        S_curr = local_search_steepest(S_curr, I, EDGE_EXCHANGE_2OPT, rng);

        long long f_curr = objective(S_curr, I);
        
        vector<int> S_best = S_curr;
        long long f_best = f_curr;

        double removal_rate = 0.30; 
        int iter = 0;

        while (sw.elapsed_ms() < T_max_ms) {
            iter++;
            vector<int> S_prime = S_curr; 

            // A. Destroy
            int n_remove = (int)std::round(I.K * removal_rate);
            if (n_remove < 1) n_remove = 1;

            if (uniform_int_distribution<int>(0, 1)(rng) == 0) {
                destroy_nodes(S_prime, n_remove, I, rng);
            } else {
                destroy_edges(S_prime, n_remove, I, rng);
            }

            // B. Repair
            repair_regret(S_prime, I, rng);

            // C. Optional LS
            if (use_ls) {
                S_prime = local_search_steepest(S_prime, I, EDGE_EXCHANGE_2OPT, rng);
            }

            // D. Acceptance (Simple Descent)
            long long f_prime = objective(S_prime, I);
            
            if (f_prime < f_curr) {
                S_curr = S_prime;
                f_curr = f_prime;

                if (f_prime < f_best) {
                    S_best = S_prime;
                    f_best = f_prime;
                }
            }
        }
        return {S_best, iter};
    }
}


// --------------------- SVG Output ---------------------
static string esc(const string& s){ return s; }

void save_svg(const Instance& I, const vector<int>& tour, const string& out_path) {
    if (tour.empty()) return;
    int W = 1000, H = 1000, margin = 40;
    int minx = INT_MAX, maxx = INT_MIN, miny = INT_MAX, maxy = INT_MIN; 
    for (auto&p: I.pts) { minx=min(minx,p.x); maxx=max(maxx,p.x); miny=min(miny,p.y); maxy=max(maxy,p.y); } 
    double sx = (maxx==minx) ? 1.0 : (double)(W-2*margin)/(maxx-minx); 
    double sy = (maxy==miny) ? 1.0 : (double)(H-2*margin)/(maxy-miny);
    auto X = [&](int x){ return margin + (x - minx) * sx; }; 
    auto Y = [&](int y){ return margin + (y - miny) * sy; };
    int minC = *min_element(I.cost.begin(), I.cost.end()); 
    int maxC = *max_element(I.cost.begin(), I.cost.end()); 
    auto rad = [&](int c){ 
        if (maxC==minC) return 6.0;
        double t = (double)(c - minC) / (maxC - minC);
        return 4.0 + 10.0 * t; 
    };
    auto green = [&](int c){ 
        if (maxC == minC) return make_tuple(0, 200, 0);
        double t = (double)(c - minC) / (maxC - minC);
        int r = (int)(255 * t);          
        int g = (int)(255 * (1 - t));    
        int b = 50;
        return make_tuple(r, g, b);
    };

    ofstream out(out_path);
    out << "<svg xmlns='http://www.w3.org/2000/svg' width='"<<W<<"' height='"<<H<<"'>\n"; 
    out << "<rect x='0' y='0' width='100%' height='100%' fill='white'/>\n";
    out << "<g stroke='black' stroke-width='1' fill='none'>\n";
    for (int i = 0; i < (int)tour.size(); ++i) {
        int u = tour[i], v = tour[(i+1)%tour.size()];
        out << "<line x1='"<<X(I.pts[u].x)<<"' y1='"<<Y(I.pts[u].y)
            <<"' x2='"<<X(I.pts[v].x)<<"' y2='"<<Y(I.pts[v].y)<<"'/>\n";
    }
    out << "</g>\n";
    out << "<g>\n";
    unordered_set<int> sel(tour.begin(), tour.end());
    for (int i = 0; i < I.N; ++i) {
        double cx = X(I.pts[i].x), cy = Y(I.pts[i].y);
        auto [r, g, b] = green(I.cost[i]);
        if (sel.count(i)) {
            out << "<circle cx='"<<cx<<"' cy='"<<cy<<"' r='"<<rad(I.cost[i])
                <<"' fill='rgb("<<r<<","<<g<<","<<b<<")' stroke='black' stroke-width='1'/>\n";
            out << "<text x='"<<cx+6<<"' y='"<<cy-6<<"' font-size='10' fill='black'>"<<i<<"</text>\n";
        } else {
            out << "<circle cx='"<<cx<<"' cy='"<<cy<<"' r='3' fill='none' stroke='gray' />\n";  
        }
    }
    out << "</g>\n";
    out << "</svg>\n";
}

struct MethodResult {
    string method; 
    long long best_obj = LLONG_MAX; 
    vector<int> best_tour; 
    vector<long long> all_objs; 
    vector<double> all_times_ms; 
};

// --- Multiple Start Local Search (MSLS) for Time Budget ---
double MSLS(const Instance& I, mt19937& rng, MethodResult& MR, int outer_runs = 20, int starts_per_run = 200) {
    MR.all_objs.clear();
    MR.all_times_ms.clear();
    MR.best_obj = LLONG_MAX;
    MR.best_tour.clear();

    Stopwatch run_sw;

    for (int r = 0; r < outer_runs; ++r) {
        run_sw.reset();
        long long best_obj_run = LLONG_MAX;
        vector<int> best_tour_run;

        for (int k = 0; k < starts_per_run; ++k) {
            double ls_time_ms = 0.0;
            auto tour = basic_LS_for_meta(I, rng, ls_time_ms);
            long long obj = objective(tour, I);
            if (obj < best_obj_run) {
                best_obj_run = obj;
                best_tour_run = tour;
            }
        }
        double run_time = run_sw.elapsed_ms();
        MR.all_objs.push_back(best_obj_run);
        MR.all_times_ms.push_back(run_time);
        if (best_obj_run < MR.best_obj) {
            MR.best_obj = best_obj_run;
            MR.best_tour = best_tour_run;
        }
    }
    double sum_time = 0.0;
    for (double t : MR.all_times_ms) sum_time += t;
    return sum_time / MR.all_times_ms.size();    
}

int main(int argc, char** argv) {
    ios::sync_with_stdio(false); 
    cin.tie(nullptr); 

    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " <instance1.txt> [instance2.txt ...] [--seed 106] [--out outdir]\n";
        return 1;
    }

    unsigned seed = 106; 
    string outdir = "out";
    vector<string> files;

    for (int i=1; i<argc; ++i) {
        string a = argv[i];
        if (a == "--seed" && i+1 < argc) { seed = (unsigned)stoul(argv[++i]); }
        else if (a == "--out" && i+1 < argc) { outdir = argv[++i]; }
        else if (a.rfind("--",0)==0) { i++; continue; } // Skip other flags
        else files.push_back(a);
    }

    filesystem::create_directories(outdir);
    mt19937 rng(seed);

    string short_summary_obj_csv = (filesystem::path(outdir) / "all_results_summary_objectives.csv").string();
    string short_summary_time_csv = (filesystem::path(outdir) / "all_results_summary_times.csv").string();

    static bool headers_written = false;
    if (!headers_written) {
        ofstream SSO(short_summary_obj_csv);
        SSO << "instance,method,summary\n";
        ofstream SST(short_summary_time_csv);
        SST << "instance,method,summary (ms)\n";
        headers_written = true;
    }

    for (const auto& path : files) {
        Instance I;
        if (!read_instance(path, I)) return 2;
        cout << "Instance: " << I.name << "   N=" << I.N << "  K=" << I.K << "\n";

        vector<MethodResult> methods;
        
        // Define Methods
        MethodResult m_msls; m_msls.method = "MSLS";
        MethodResult m_lns_ls; m_lns_ls.method = "LNS_With_LS";
        MethodResult m_lns_no_ls; m_lns_no_ls.method = "LNS_No_LS";

        // 1. Run MSLS to determine time budget
        cout << "Running MSLS benchmark (20 runs)...\n";
        double avg_msls_time = MSLS(I, rng, m_msls, 20, 200); 
        cout << "Avg MSLS Time: " << avg_msls_time << " ms. Using this as budget for LNS.\n";
        methods.push_back(m_msls);

        // 2. Run LNS
        vector<int> iterations_with_ls;
        vector<int> iterations_no_ls;

        // LNS WITH Local Search
        cout << "Running LNS (With LS) - 20 runs...\n";
        for(int r=0; r<20; ++r) {
            print_progress((r+1)/20.0, "LNS+LS");
            Stopwatch sw;
            auto [best_sol, iters] = LNS_Ops::run_LNS(I, avg_msls_time, true, rng);
            double t = sw.elapsed_ms();
            
            long long obj = objective(best_sol, I);
            m_lns_ls.all_objs.push_back(obj);
            m_lns_ls.all_times_ms.push_back(t); // Should be roughly avg_msls_time
            if(obj < m_lns_ls.best_obj) {
                m_lns_ls.best_obj = obj;
                m_lns_ls.best_tour = best_sol;
            }
            iterations_with_ls.push_back(iters);
        }
        methods.push_back(m_lns_ls);
        cerr << "\n";

        // LNS WITHOUT Local Search
        cout << "Running LNS (No LS) - 20 runs...\n";
        for(int r=0; r<20; ++r) {
            print_progress((r+1)/20.0, "LNS-NoLS");
            Stopwatch sw;
            auto [best_sol, iters] = LNS_Ops::run_LNS(I, avg_msls_time, false, rng);
            double t = sw.elapsed_ms();
            
            long long obj = objective(best_sol, I);
            m_lns_no_ls.all_objs.push_back(obj);
            m_lns_no_ls.all_times_ms.push_back(t);
            if(obj < m_lns_no_ls.best_obj) {
                m_lns_no_ls.best_obj = obj;
                m_lns_no_ls.best_tour = best_sol;
            }
            iterations_no_ls.push_back(iters);
        }
        methods.push_back(m_lns_no_ls);
        cerr << "\n";

        // Save Iteration Counts
        string iter_csv = (filesystem::path(outdir) / (I.name + "_LNS_iterations.csv")).string();
        ofstream F_iter(iter_csv);
        F_iter << "run,LNS_With_LS,LNS_No_LS\n";
        for(int r=0; r<20; ++r) {
            F_iter << (r+1) << "," << iterations_with_ls[r] << "," << iterations_no_ls[r] << "\n";
        }
        cout << "Saved LNS iterations to " << iter_csv << "\n";

        // --- Summaries + Best Tours + SVGs ---
        string summary_csv = (filesystem::path(outdir) / (I.name + "_results_summary.csv")).string();
        ofstream S(summary_csv);
        S << "instance,method,runs,min_obj,max_obj,avg_obj,best_obj,avg_time_ms\n";
        
        ofstream SSO(short_summary_obj_csv, ios::app);
        ofstream SST(short_summary_time_csv, ios::app);

        for (auto &MR : methods) {
            if (MR.all_objs.empty()) continue; 
            
            long long mn_obj = LLONG_MAX, mx_obj = LLONG_MIN; 
            long double sum_obj = 0;
            for (auto v : MR.all_objs) { mn_obj = min(mn_obj, v); mx_obj = max(mx_obj, v); sum_obj += v; }
            long double avg_obj = sum_obj / (long double)MR.all_objs.size();

            double mn_time = 1e300, mx_time = -1e300, sum_time = 0;
            for (auto t : MR.all_times_ms) { mn_time = min(mn_time, t); mx_time = max(mx_time, t); sum_time += t; }
            double avg_time = sum_time / (double)MR.all_times_ms.size();

            S << I.name << "," << MR.method << "," << MR.all_objs.size() << ","
              << mn_obj << "," << mx_obj << "," << (long long)(avg_obj + 0.5) << "," << MR.best_obj << ","
              << avg_time << "\n";

            SSO << I.name << "," << MR.method << "," << (long long)(avg_obj + 0.5) << "\n";
            SST << I.name << "," << MR.method << "," << fixed << setprecision(3) << avg_time << "\n";

            if (!MR.best_tour.empty()) {
                string best_txt = (filesystem::path(outdir) / (I.name + "_best_" + MR.method + ".txt")).string();
                ofstream B(best_txt);
                for (int i = 0; i < (int)MR.best_tour.size(); ++i) {
                    if (i) B << " ";
                    B << MR.best_tour[i];
                }
                string svg = (filesystem::path(outdir) / (I.name + "_best_" + MR.method + ".svg")).string();
                save_svg(I, MR.best_tour, svg);
            }
        }
    }
    return 0;
}